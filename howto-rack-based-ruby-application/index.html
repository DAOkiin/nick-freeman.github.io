
<head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">

<title>HowTo: Sample ruby application</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">

<link rel="stylesheet" type="text/css" href="../assets/css/styles.css?v=cad2a2774a">
<link href="https://fonts.googleapis.com/css?family=Merriweather:400,700,700italic,400italic" rel="stylesheet">
    <link rel="shortcut icon" href="../favicon.png" type="image/png">
    <link rel="canonical" href="index.html">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <link rel="amphtml" href="amp/index.html">
    
    <meta property="og:site_name" content="Nick Freeman">
    <meta property="og:type" content="article">
    <meta property="og:title" content="HowTo: Sample ruby application">
    <meta property="og:description" content="Создавая docker-образ для разработки на ruby, я столкнулся с тем, что на github нет возможности получить контрольную сумму для файлов релизов. Проверка целостности скаченного архива во время сборки, на мой взгляд, является хорошей практикой. Для решения проблемы я создал простое приложение используя Sinatra и Heroku, этапы создания которого рассмотрены в">
    <meta property="og:url" content="http://localhost:2368/howto-rack-based-ruby-application/">
    <meta property="og:image" content="http://localhost:2368/content/images/2017/10/ruby1.png">
    <meta property="article:published_time" content="2017-10-10T11:54:00.000Z">
    <meta property="article:modified_time" content="2017-10-10T11:55:42.000Z">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="HowTo: Sample ruby application">
    <meta name="twitter:description" content="Создавая docker-образ для разработки на ruby, я столкнулся с тем, что на github нет возможности получить контрольную сумму для файлов релизов. Проверка целостности скаченного архива во время сборки, на мой взгляд, является хорошей практикой. Для решения проблемы я создал простое приложение используя Sinatra и Heroku, этапы создания которого рассмотрены в">
    <meta name="twitter:url" content="http://localhost:2368/howto-rack-based-ruby-application/">
    <meta name="twitter:image" content="http://localhost:2368/content/images/2017/10/ruby1.png">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Nick Freeman">
    <meta property="og:image:width" content="360">
    <meta property="og:image:height" content="360">
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "Nick Freeman",
        "logo": {
            "@type": "ImageObject",
            "url": "http://localhost:2368/content/images/2017/10/01.png",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Nick Freeman",
        "url": "http://localhost:2368/author/nick/",
        "sameAs": []
    },
    "headline": "HowTo: Sample ruby application",
    "url": "http://localhost:2368/howto-rack-based-ruby-application/",
    "datePublished": "2017-10-10T11:54:00.000Z",
    "dateModified": "2017-10-10T11:55:42.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "http://localhost:2368/content/images/2017/10/ruby1.png",
        "width": 360,
        "height": 360
    },
    "description": "Создавая docker-образ для разработки на ruby, я столкнулся с тем, что на github нет возможности получить контрольную сумму для файлов релизов. Проверка целостности скаченного архива во время сборки, на мой взгляд, является хорошей практикой. Для решения проблемы я создал простое приложение используя Sinatra и Heroku, этапы создания которого рассмотрены в",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:2368/"
    }
}
    </script>

    <script type="text/javascript" src="../public/ghost-sdk.js?v=cad2a2774a"></script>
<script type="text/javascript">
ghost.init({
	clientId: "ghost-frontend",
	clientSecret: "f0656e80b35b"
});
</script>
    <meta name="generator" content="Ghost 1.9">
    <link rel="alternate" type="application/rss+xml" title="Nick Freeman" href="../rss/index.html">
    <link href="https://cdn.rawgit.com/nick-freeman/4ac4f363107d3c65ad9a13813dce5625/raw/adcbf9eee5e51cbbe641ccfe2e9ba04380a68db3/prism.css" rel="stylesheet">
</head>

<body class="post-template">
    <div id="site-wrapper" class="c-site-wrapper">
        <div id="site-viewport" class="c-site-viewport">
            <div id="site-sidebar" class="c-site-sidebar">
    <div class="c-sidebar-header" style="background-image: url(https://casper.ghost.org/v1.0.0/images/blog-cover.jpg)">
        <a class="c-sidebar-header__link" href="../" title="Nick Freeman">
            <img class="c-sidebar-header__image" src="../content/images/2017/10/01.png" alt="Nick Freeman">
        </a>
    </div>

    <h2 class="c-sidebar-blog-title">
        <a class="c-sidebar-blog-title__link" href="../" title="Nick Freeman">
            Nick Freeman
        </a>
    </h2>

    <h2 class="c-sidebar-blog-description">
        Full-Stack Developer
    </h2>

    <div class="c-sidebar-contact-links">
        <a class="c-sidebar-contact-links__item" href="index.html#" target="_blank">
            github
        </a>

        <a class="c-sidebar-contact-links__item" href="index.html#" target="_blank">
            twitter
        </a>

        <a class="c-sidebar-contact-links__item" href="index.html#" target="_blank">
            linkedin
        </a>

        <a class="c-sidebar-contact-links__item" href="index.html#">
            email
        </a>
    </div>

    <div class="c-sidebar-navigation">
        <a class="c-sidebar-navigation__item" href="http://blog.nfreeman.pw/" title="Less words, more data">
            Less words, more data
        </a>
</div>

    <div class="c-sidebar-promotion-links">
        <a class="c-sidebar-promotion-links__item" href="index.html#" target="_blank">
            • Link
        </a>

        <a class="c-sidebar-promotion-links__item" href="index.html#" target="_blank">
            • Link
        </a>
    </div>
</div>
            <div id="site-content" class="c-site-content">
                <div class="c-mobile-header">
    <a href="index.html#" id="mobile-menu" class="c-mobile-header__link" title="Menu">
        Menu
    </a>

    <a class="c-mobile-header__logo" href="../" title="Nick Freeman">
        <img class="c-mobile-header__logo__image" src="../content/images/2017/10/01.png" alt="Nick Freeman">
    </a>
</div>                    <div class="c-post-view post">
        <div class="c-page-title">
            <h1 class="c-page-title__heading">
                HowTo: Sample ruby application
            </h1>

            <div class="c-post-view-meta">
    October 10, 2017

</div>        </div>

        <div class="c-post-view__content">
            <div class="kg-card-markdown"><p>Создавая docker-образ для разработки на ruby, я столкнулся с тем, что на github нет возможности получить <a href="https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D1%81%D1%83%D0%BC%D0%BC%D0%B0">контрольную сумму</a> для файлов релизов. Проверка целостности скаченного архива во время сборки, на мой взгляд, является хорошей практикой. Для решения проблемы я создал простое приложение используя Sinatra и Heroku, этапы создания которого рассмотрены в этой статье.</p>
<h2 id="">Немного о используемых инструментах</h2>
<p>Вам потребуется<br>
Heroku CLI<br>
Ruby 2.4.1<br>
Sinatra<br>
Rack<br>
Webrick<br>
Sqllite<br>
Postgresql</p>
<h3 id="helloworld">Hello World!</h3>
<p>Приложение я буду хостить на heroku, по этому добавим файл Procfile, который является стандартным entrypoint для этого сервиса. Так же добавим Gemfile, app.rb и сразу напишем тесты.</p>
<pre><code># app.rb
require 'sinatra'

get '/' do
  'Hello World!'
end
</code></pre>
<pre><code># spec_helper.rb
require 'rack/test'

ENV['RACK_ENV'] = 'test'

RSpec.configure do |config|
  config.tty = true
  config.formatter = :documentation
  config.include Rack::Test::Methods

  def app
    Sinatra::Application
  end
end
</code></pre>
<pre><code># app_spec.rb
require './spec_helper'
require './app'

describe 'The HelloWorld App' do

  it 'should greet' do
    get '/'

    expect(last_response).to be_ok
    expect(last_response.body).to eq('Hello World!')
  end
end
</code></pre>
<pre><code># Prockfile
web: ruby app.rb -p $PORT
</code></pre>
<pre><code># Устанавливаем гемы
$ bundle i
# Запускаем тесты
$ rspec app.rb
# Тесты зелёные, создаём приложение на Heroku
$ heroku create latest-sha
# Добавим remote в git
$ git remote add heroku https://git.heroku.com/latest-sha.git
# Коммитим и пушим
$ git add .
$ git commit -m 'Init'
$ git push heroku master
</code></pre>
<p>Мы создали Hello Word приложение, написали тест и хелпер к ним, далее приступим к написанию приложения.</p>
<h3 id="">Пишем приложение</h3>
<p>От приложения нам потребуются следующие вещи:<br>
Возможность по адресу имя_github_аккаунта/имя_репозитория/имя_релиза/формат_архива получить контрольную сумму архива<br>
Пример: <code>latest-sha.herokuapp.com/ruby/ruby/v2_4_1/tarball</code><br>
Периодически проверять, что сохранен SHA для актуального архива релиза и актуальность списка релизов</p>
<p>Добавление репозиториев я решил реализовать вручную, для того чтобы не добавлять аутентификацию и во избежание усложнения приложения.</p>
<p>Доступные данные о количестве релизов в формате JSON возможно получить из <a href="https://api.github.com/repos/ruby/ruby/tags">Github API</a></p>
<p>Нам надо написать класс, который будет брать из БД адрес репозитория и парсить вышепреведенный JSON<br>
name: имя релиза<br>
zipball_url: URL zipball архива<br>
tarball_url: URL tarball архива<br>
commit_sha: контрольная сумма актуального коммита<br>
После чего будет выкачивать эти архивы, получать контрольную сумму для них и сохранять все данные в БД.</p>
<p>Дополнительно в приложении нам понадобятся следующие вещи:<br>
БД: для production используем postgresql, для test и development - sqlite3<br>
Ruby-Make(rake) для работы с миграциями<br>
Activerecord для работы с моделями</p>
<pre><code># Gemfile
source 'https://rubygems.org'
ruby '2.4.0'

gem 'sinatra'
gem 'sinatra-activerecord'
gem 'rake'

group :production do
  gem 'pg'
end

group :development, :test do
  gem 'rack-test', require: 'rack/test'
  gem 'rspec'
  gem 'sqlite3'
end
</code></pre>
<p>Добавим config/environment.rb в котором укажем настройки БД для конкретного environment и подключим его в <code>app.rb</code></p>
<pre><code># config/environment.rb
require 'sinatra/activerecord'

configure :development do
 set :database, 'sqlite3:dev.db'
 set :show_exceptions, true
end

configure :test do
 set :database, 'sqlite3:test.db'
end

# app.rb
...
require './config/environment'
...
</code></pre>
<p>Добавим Rakefile</p>
<pre><code># Rakefile
require 'sinatra/activerecord/rake'
require './app'
</code></pre>
<p>Создадим БД для development и test окружения</p>
<pre><code>$ bundle exec rake db:create
$ bundle exec rake db:create RACK_ENV=test
</code></pre>
<p>Нам понадобится 3 модели, Owner,  Repo и Tag<br>
В папке models создадим файлы owner.rb, repo.rb и tag.rb</p>
<pre><code>#models/owner.rb
class Owner &lt; ActiveRecord::Base
  has_many :repos
end

#models/repo.rb
class Repo &lt; ActiveRecord::Base
    belongs_to :owner
    has_many :tags
end

#models/tag.rb
class Tag &lt; ActiveRecord::Base
  belongs_to :repo
end
</code></pre>
<p>Подключаем их в environment.rb</p>
<pre><code>#config/environment.rb
require 'sinatra/activerecord'
Dir["./models/*.rb"].each {|file| require file }
...
</code></pre>
<p>Создаем пустые файлы миграций и заполняем их</p>
<pre><code>$ bundle exec rake db:create_migration NAME=create_owners
$ bundle exec rake db:create_migration NAME=create_repos
$ bundle exec rake db:create_migration NAME=create_tags
</code></pre>
<pre><code>class CreateOwners &lt; ActiveRecord::Migration[5.1]
  def change
    create_table :owners do |t|
      t.string :name
    end
  end
end

class CreateRepos &lt; ActiveRecord::Migration[5.1]
  def change
    create_table :repos do |t|
      t.string :name
      t.integer :owner_id
    end
  end
end

class CreateTags &lt; ActiveRecord::Migration[5.1]
  def change
    create_table :tags do |t|
      t.string :name
      t.string :zipball_url
      t.string :tarball_url
      t.string :zipsha
      t.string :tarsha
      t.string :commit_sha
      t.integer :repo_id
    end
  end
end
</code></pre>
<p>Создадим файл seeds.rb, в который добавим owner и repo</p>
<pre><code># db/seeds.rb
owner = Owner.create(name: 'ruby')
repo = Repo.new(name: 'ruby')
repo.owner = owner
repo.save
</code></pre>
<p>Выполним миграции и посеем данные</p>
<pre><code>$ bundle exec rake db:migrate 
$ bundle exec rake db:migrate RACK_ENV=test
$ bundle exec rake db:seed
$ bundle exec rake db:seed RACK_ENV=test
</code></pre>
<p>Теперь нужно создать класс, который будет брать репозиторий, получать список тегов, загружать архивы и получать SHA256 для них, назовем его Checksum. Сначала напишем тесты.</p>
<p>В соответствии с заявленным функционалом, нам потребуется протестировать:</p>
<ul>
<li>Скачивание и удаление файлов</li>
<li>Вычисление корректного SHA для файлов</li>
<li>Удаление не актуальных тегов</li>
<li>Проброс исключения в случае превышения лимита загрузок</li>
</ul>
<pre><code># checksum_spec.rb
require './spec_helper'
require './app'
require './checksum'

RSpec.describe Checksum do
  it 'should save and delete files'
  it 'should return correct sha'
  it 'should delete old tags'
  it 'should throw error when file downloaded more than 3 times'
end
</code></pre>
<p>Добавим файл checksum.rb и напишем класс Checksum.<br>
Нам понадобятся следующие библиотеки:<br>
open-uri - скачивание данных<br>
json - работа с JSON<br>
digest - создание контрольной суммы<br>
logger - для логов</p>
<pre><code class="language-ruby">require 'open-uri'
require 'json'
require 'digest'
require 'logger'

class Checksum 

  def initialize
    @logger = Logger.new(STDOUT)
    @logger.level = Logger::INFO
  end
  
end
</code></pre>
<p>Напишем методы для скачивания, получения хеш-суммы и удаления файлов.</p>
<pre><code class="language-ruby">...
  def load_file(file_name, link)
    io = open(link).read
    File.write(file_name, io)
  end

  def get_sha(file_name)
    Digest::SHA256.file(file_name).hexdigest
  end

  def delete_files(arr)
    arr.map {|file| File.delete(file) }
  end
...
</code></pre>
<p>Поскольку нужно точно убедиться в том, что файл скачался верно и хэш-сумма корректна, то файл нужно скачать минимум два раза. Но если после трёх скачиваний хэш каждый раз разный, то что-то пошло не так. Напишем метод verify, который будет запускать вышеописанные методы и отлавливать ошибки в момент верификации корректности хэш-суммы.</p>
<pre><code class="language-ruby">...
  def verify(link, name)
    files = []
    sha_list = Hash.new(0)
    stop = false
    step = 0
    @logger.info("Verify #{name}. Looking for #{link}")
    begin
      step += 1

      raise RuntimeError.new('File loads more than 3 times') if step &gt; 3
      file_name = "#{name}#{step}"

      load_file(file_name, link)
      files.push(file_name)

      sha_list[ get_sha(file_name) ] += 1
      result_sha = sha_list.map{|k,v| k if v &gt; 1}.compact[0]

      if !result_sha.nil? &amp;&amp; step &gt; 1
        delete_files(files)
        stop = true
        return result_sha
      end
    rescue RuntimeError =&gt; e
      stop = true
      delete_files(files)
      @logger.warn( "#{e.message}: #{link}" )
      raise e
    rescue =&gt; e
      @logger.warn(e.message)
      stop = true
      delete_files(files)
    end while !stop
  end
...
</code></pre>
<p>Добавим метод который проходящит по всем репозиториям, скачивает файлы тегов, верифицирует их сохраняет данные в БД.</p>
<pre><code class="language-ruby">  def start
    Repo.all.to_a.each do |repo|
      api_url = "https://api.github.com/repos/#{repo.owner.name}/#{repo.name}/tags"
      git_tags = JSON.load(open(api_url))
      actual_tags_names = sanitize_repo_tags(git_tags, repo)
      git_tags.each do |git_tag|
        Thread.new do 
          tag = actual_tags_names.include?(git_tag['name']) ? repo.tags.select {|tag| tag.name == git_tag['name'] }[0] : repo.tags.new
          if tag.commit_sha != git_tag['commit']['sha']
            tag.name = git_tag['name']
            tag.zipball_url = git_tag['zipball_url']
            tag.tarball_url = git_tag['tarball_url']
            tag.commit_sha = git_tag['commit']['sha']
            tag.tarsha = verify(git_tag['tarball_url'], git_tag['name'])
            tag.zipsha = verify(git_tag['zipball_url'], git_tag['name'])
            if tag.save
              @logger.info( "Succefully updated: #{repo.owner.name}/#{repo.name}: tag #{tag.name}" )
            else
              @logger.info( "Some error with: #{repo.owner.name}/#{repo.name}: tag #{tag.name}" )
            end
          end
        end
      end
    end
    Thread.list.each { |t| t.join if t != Thread.current }
  end
</code></pre>
<p>Также необходим метод удаляющий неактуальные теги</p>
<pre><code class="language-ruby">  def sanitize_repo_tags(git_tags, repo)
    old_tags = repo.tags.map(&amp;:name) - git_tags.map {|d| d['name'] }
    repo.tags.each { |tag| tag.destroy if old_tags.include?(tag.name) }
    repo.tags.reject { |tag| old_tags.include?(tag.name) }.map { |tag| tag.name }
  end

</code></pre>
<p>Добавим тесты.</p>
<pre><code class="language-ruby">require './spec_helper'
require './app'

RSpec.describe Checksum do
  before(:each) do
    owner = Owner.create(name: 'ruby')
    owner.repos.create(name: 'ruby')
  end

  before { allow(subject).to receive_message_chain(:open, :read).and_return("some data") }

  it "should delete old tags" do
    repo = Repo.first
    repo.tags.create(name: 'old_tag')
    new_tags = [{'name' =&gt; 'new_tag' }]

    subject.sanitize_repo_tags(new_tags, repo)
    expect( repo.tags.where(name: 'old_tag') ).to be_empty
  end

  it 'should save and delete files' do
    files_names = %w(1 2 3)

    # [9, 9, 9] because of file lenght
    expect( files_names.map { |n| subject.load_file(n, 'some link') } ).to eq( [9, 9, 9] )
    expect( subject.delete_files( files_names ) ).to eq( [1, 1, 1] )
  end

  it 'should return correct sha' do
    #sha for 'some data'
    correct_sha = '1307990e6ba5ca145eb35e99182a9bec46531bc54ddf656a602c780fa0240dee'

    expect( subject.verify('some url', 'file_name') ).to eq(correct_sha)
  end

  it 'should throw error when file downloaded more than 3 times' do
    hex = Object.new
    def hex.hexdigest ; Random.rand ; end

    allow(Digest::SHA256).to receive_messages( :file =&gt; hex )

    expect{ subject.verify('some link', 'file_name') }.to raise_error(RuntimeError)
  end
end
</code></pre>
</div>
        </div>

        <div class="c-post-view__footer">
            <div class="c-post-view-share">
    <a class="c-post-view-share__item c-post-view-share__item--twitter" href="https://twitter.com/intent/tweet?text=HowTo%3A%20Sample%20ruby%20application&amp;url=http://localhost:2368/howto-rack-based-ruby-application/" onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
        Share on Twitter
    </a>
    <a class="c-post-view-share__item c-post-view-share__item--facebook" href="https://www.facebook.com/sharer/sharer.php?u=http://localhost:2368/howto-rack-based-ruby-application/" onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
        Share on Facebook
    </a>
    <a class="c-post-view-share__item c-post-view-share__item--google" href="https://plus.google.com/share?url=http://localhost:2368/howto-rack-based-ruby-application/" onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
        Share on Google+
    </a>
</div>            <div class="c-post-view-prev-next">
            <article class="c-post-view-prev-next__item">
                <div class="c-post-view-prev-next__image c-post-view-prev-next__image--placeholder">
                    <span class="c-post-view-prev-next__image__label c-post-view-prev-next__image__label--next">
                        No Newer Posts
                    </span>
                </div>
            </article>

            <article class="c-post-view-prev-next__item post">
                <a class="c-post-view-prev-next__image" href="../docker4dev-chast-3/" title="Docker4Dev: Часть 3.  Ежедневные советы">
                    <img class="c-post-view-prev-next__image__img" src="../content/images/2017/10/14098888813_1047e39f08--1--2.jpg" alt="Docker4Dev: Часть 3.  Ежедневные советы">
                    <span class="c-post-view-prev-next__image__label c-post-view-prev-next__image__label--previous">
                        Previous Post
                    </span>
                </a>

                <h3 class="c-post-view-prev-next__title">
                    <a href="../docker4dev-chast-3/" title="Docker4Dev: Часть 3.  Ежедневные советы">Docker4Dev: Часть 3.  Ежедневные советы</a>
                </h3>
            </article>
</div>            <!--<div class="c-disqus-comments">
    <div id="disqus_thread">
        <a class="c-disqus-comments__button" onclick="WillowGhostTheme.loadDisqusComments();">
            Load Comments
        </a>
    </div>
    <script>
        var WillowGhostTheme = {
            loadDisqusComments: function () {

                var d = document, s = d.createElement('script');
                s.src = '//yourssite.disqus.com/embed.js';
                s.setAttribute('data-timestamp', +new Date());
                (d.head || d.body).appendChild(s);

            }
        };
    </script>
</div>-->
        </div>
    </div>

            </div>
        </div>
    </div>

    <script src="../assets/js/scripts.js?v=cad2a2774a"></script>
    <script type="text/javascript" src="https://cdn.rawgit.com/nick-freeman/4263a9215bc3153c0a8cb44339260c64/raw/14ce0454b32fb236a1b6c21d139d2421e69abdbf/prism.js"></script>
</body>
